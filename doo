#!/bin/bash -u
set -o pipefail

help() {
echo 'Usage: doo COMMAND [arg...]

A docker assistant to build, ship and run containers.

The image NAME is built, tagged and pushed using the name of the current directory and the env var DOCKER_REPO.

dev and go run containers by using all *.env files found in the current directy in --env-file arguments and
all directories that appears in the COPY Dockerfile directives with --volume.

Commands:
  b, build        docker build $DOCKER_REPO/$NAME
  t, tag          docker tag   $DOCKER_REPO/$NAME:VERSION (VERSION: sha1 if git repo and/or latest)
  p, push         docker push  $DOCKER_REPO/$NAME

  bgo, buildgo    build go binary in docker (docker run -v $PWD:/go/src/<package> golang:1.8.0 go build)

  u, up                        docker compose up -d by using the first .yml found in the current directory
  dc [COMPOSE_FILE] ARGS...    docker compose ARGS  by using the first .yml found in the current directory or
                               a given compose file

  d, dev          docker run -ti $DOCKER_REPO/$NAME by loading env-files and mounting current directories
  g, go  IMAGE    docker run $IMAGE                 by loading env-files and mounting current directories
'
}

GO_VERSION=1.8.0

get_sha1() {
  GIT_SHA1=${GIT_SHA1:-"no"}
  if [[ "$GIT_SHA1" != "no" ]]; then
    echo $GIT_SHA1
  else
    if [[ $(git rev-parse 2> /dev/null; echo $?) == "0" ]]; then
      git rev-parse --short HEAD
    else
      echo "latest" && return
    fi
  fi
}

env_files() {
  local arg=""
  while read env_file; do
    arg="$arg --env-file=$(readlink -f $env_file)"
  done < <(find . -name "*.env" -type f)
  echo "$arg"
}

mounted_volumes() {
  local arg=""
  while read copy_line; do
    src=$(pwd)/$(cut -d ' ' -f2 <<< $copy_line)
    dst=$(cut -d ' ' -f3 <<< $copy_line)
    arg="$arg -v $src:$dst"
  done < <(grep COPY Dockerfile)
  echo "$arg"
}

set_docker_repo() {
  [ -f .docker.env ] && export $(cat .docker.env | xargs)
  DOCKER_REPO=${DOCKER_REPO:-""}
  [[ $DOCKER_REPO == "" ]] && echo "err: DOCKER_REPO not set" && return 1
}

doo_cmd() {
  declare name=$NAME
  declare cmd=$1
  shift

  declare long_cmd="" h=${DOCKER_MACHINE_NAME:-$(hostname)}

  case $cmd in
    b|build)
      if [ "$EUID" -ne 0 ]; then
        sudo chown -R $USER:$USER .
      fi
      set_docker_repo
      long_cmd="docker build --rm -t $DOCKER_REPO/$name ."
    ;;
    bgo|buildgo)
      set_docker_repo
      local commit=${1:-"$(get_sha1)"} && shift
      local go_project_path=$(pwd | sed "s|.*/go/src/||")
      declare build_env="-e GOBIN=/go/bin/ -e CGO_ENABLED=0 -e GOPATH=/go"
      declare image="golang:$GO_VERSION"
      declare build_date=$(date "+%Y-%m-%dT%H:%M:%S")
      long_cmd="docker run --rm --hostname $h -v $(pwd):/go/src/$go_project_path -w /go/src/$go_project_path $build_env $image go build -ldflags \"-X main.gitCommit=${commit} -X main.buildDate=$build_date\""
    ;;
    d|dev)
      set_docker_repo
      long_cmd="docker run --rm -ti $(env_files) $(mounted_volumes) $@ $DOCKER_REPO/$name"
    ;;
    g|go)
      set_docker_repo
      local opts=""
      if [[ "$1" =~ ^- ]]; then
        opts="$1 $2" && shift && shift
      fi
      local go_name=${1:-""} && shift
      [[ $go_name && "" ]] && echo "err: NAME not set" && return 1
      declare workdir=$name
      long_cmd="docker run --rm -ti --hostname $h $(env_files) -v $(pwd):/$name -w /$workdir $opts $DOCKER_REPO/$go_name $@"
    ;;
    dc)
      local compose_file=$1 && shift
      declare compose_project=$(basename $compose_file | sed "s/.yml//")

      long_cmd="docker-compose -f $compose_file -p $compose_project $@"
    ;;
    u|up)
      declare compose_file=$(find . -maxdepth 1 -name "*.yml")
      long_cmd="docker-compose -f $compose_file up -d"
    ;;
    t|tag)
      declare sha1=$(get_sha1)
      if [[ "$sha1" != "latest" ]]; then
        echo "docker tag $DOCKER_REPO/$name $DOCKER_REPO/$name:$sha1"
      fi
    ;;
    p|push)
      set_docker_repo
      long_cmd="docker push $DOCKER_REPO/$name"
    ;;
    *)
      echo "doo: '$cmd' is not a dooo command."
      echo "See 'doo help'."
      exit 1
    ;;
  esac

  echo "$long_cmd"
}

main() {
  local cmd=${1:-""}
  shift

  QUIET="no"
  if [[ "$cmd" == "-q" ]]; then
    QUIET="yes"
    cmd=${1:-""}
    shift
  fi

  JSON=${JSON:-"no"}

  declare log="false"
  case $cmd in
    b|build|dc|u|up|t|tag|p|push)
      log="true"
      ;;
    bgo|buildgo)
      local commit=${1:-"$(get_sha1)"}
      declare image="golang:$GO_VERSION"
      declare build_date=$(date "+%Y-%m-%dT%H:%M:%S")
      echo "[$image] go build -ldflags \"-X main.gitCommit=${commit} -X main.buildDate=$build_date\""
      log="true"
      ;;
    d|dev|g|go)
      ;;
    bu)
      doo b
      doo u
      exit $?
    ;;
    w|watch)
      rm -f ~/.doo/*.doo
      while true; do
        clear;
        echo "[$(date +%Y%m%d-%Hh%Mm%S)] > doo watch..."
        find ~/.doo -type f -name "*.doo" | xargs -n1 head -1 \
          | tail -6 | sort -r \
          | jq -c '{date:.timestamp,status:.status,action:.cmd,cmd:.long_cmd,msg:.title}'
        sleep 1
      done
      ;;
    ""|h|help)
      help
      exit 0 ;;
    *)
      echo "doo: '$cmd' is not a doo command."
      echo "See 'doo help'."
      exit 1 ;;
  esac

  # Use the current directory as the docker image name
  NAME=$(basename $(pwd))

  # Try to get name from DOCKER_NAME env var defined in .docker.env
  if [[ -f .docker.env ]]; then
    n=$(grep DOCKER_NAME .docker.env | sed "s/DOCKER_NAME=//")
    if [[ "$n" != "" ]]; then
      NAME=$n
    fi
  fi

  # Get the command to execute
  declare long_cmd="$(doo_cmd $cmd "$@")"

  # Execute the command without posting result

  if [[ $log == "false" ]]; then
    VERBOSE=${VERBOSE:-0}
    if [[ $VERBOSE == "1" ]]; then
      echo "$long_cmd"
    fi
    eval $long_cmd
    exit $?
  fi

  # Execute the command by posting result

  mkdir -p ~/.doo
  declare logfile=~/.doo/$(date +%s.$cmd.$(date +%N)$RANDOM.doo)

  declare start=$(date +%s)
  declare status=pending

  declare bold="\e[1m"
  declare reset_bold="\e[0m"
  declare cyan="\e[36m"
  declare green="\e[32m"
  declare purple="\e[35m"
  declare red="\e[31m"
  declare reset="\e[39m"

  declare color=$cyan

  # Print info
  echo '{
    "timestamp":"'$start'",
    "name":"'$NAME'",
    "status":"pending",
    "cmd":"'$cmd'",
    "long_cmd":"'$(sed "s/\"/'/g" <<< $long_cmd)'",
    "logfile":"'$logfile'"
  }' | jq -c . >> $logfile
  echo >> $logfile

  eval $long_cmd 2>&1 | tee -a $logfile
  status=$?

  #  docker-compose can return 0 and have ERROR :-/
  if [[ $(grep -ic error $logfile) -gt 0 ]]; then
    status=1
  fi

  case $status in
    0 ) status=OK;    color1=$cyan  ; color2=$green; htmlColor=#03A9F4; htmlColor2=#4CAF50 ;;
    * ) status=ERROR; color1=$purple; color2=$red  ; htmlColor=#9C27B0; htmlColor2=#F44336 ;;
  esac

  fullmsg() {
    while read line; do
      echo "$line<br>" \
        | sed -e "s|\"|'|g" -e 's|\\|\\\\|g' \
        | strings
    done < <(
      tail -n +3 $logfile | grep -v "Sending"
    )
  }

  # Update first logfile line with the result
  declare end=$(date +%s)
  declare msg="$(tail -1 $logfile | strings)"
  declare duration=$(($end - $start))

  declare from=$(hostname)
  DOCKER_MACHINE_NAME=${DOCKER_MACHINE_NAME:-""}
  [[ $DOCKER_MACHINE_NAME != "" ]] && from=$DOCKER_MACHINE_NAME

  print_result() {
    declare full=${1:-""}
    [[ "$full" == "full" ]] && full='"message":"'$(fullmsg)'",'
    echo '{
      "timestamp":"'$(date +%s)'",
      "name":"'$NAME'",
      "source":"'$from'",
      "cmd":"'$cmd'",
      "status":"'$status'",
      "duration_sec":"'$duration'",
      "long_cmd":"'$(sed "s/\"/'/g" <<< $long_cmd)'",
      "title":"'$msg'",
      '$full'
      "logfile":"'$logfile'"
    }'
  }

  result() { print_result | jq -c .; }

  sed -i "1s|.*|$(result)|" $logfile

  if [[ "$JSON" == "yes" ]]; then
    print_result | jq -c .
  fi

  if [[ "$QUIET" != "yes" ]]; then
    echo -e "$color2$bold$status$reset_bold$reset: $cyan$long_cmd$reset"
  fi

  # Post event
  if [[ "${DOO_ES:-}" != "" ]]; then
    declare sha1=$(print_result full | sha1sum | cut -c1-12)
    status=$(curl -s --connect-timeout 2 -XPOST "$DOO_ES/doo/commands/$sha1" -d "$(print_result full)" -o /dev/null -w "%{http_code}")
    if [[ "$status" != "201" &&  "$QUIET" != "yes" ]]; then
      echo -e "$red${bold}KO$reset_bold$reset: ${cyan}curl -XPOST $DOO_ES/doo/command... failed with status $status$reset"
    fi
  fi
}

main "$@"